//go:build ignore
// +build ignore

// types_generate.go is meant to run with go generate.
// The generated source is written to gen_types.go and is meant to be checked into git.

package main

// import (
// 	"bytes"
// 	"go/format"
// 	"log"
// 	"os"

// 	"github.com/StackExchange/dnscontrol/v4/pkg/rtypectl"
// )

// gen_types_tmpl := ```
// // Code generated by "go run types_generate.go"; DO NOT EDIT.

// package rtypes

// // for each type in the TYPES.yml file, generate a struct with the appropriate fields.
// {{- range .Types }}
// {{- . }}
// {{- end }}

// ```

// func main() {
// 	db, err := rtypectl.New("TYPES.yml")
// 	if err != nil {
// 		fatalIfErr(err)
// 	}

// 	b := &bytes.Buffer{}
// 	b.WriteString(packageHdr)

// 	for _, rt := range db.Types {
// 		b.WriteString(GenStruct(rt))
// 	}

// 	// gofmt
// 	res, err := format.Source(b.Bytes())
// 	if err != nil {
// 		b.WriteTo(os.Stderr)
// 		log.Fatal(err)
// 	}

// 	// write result
// 	f, err := os.Create("gen_types.go")
// 	fatalIfErr(err)
// 	defer f.Close()
// 	f.Write(res)
// }

// func fatalIfErr(err error) {
// 	if err != nil {
// 		log.Fatal(err)
// 	}
// }
// func GenStruct(rt *rtypectl.RTypeConfig) string {

// 	b := &bytes.Buffer{}

// tmpl, err := template.New("gen_types.go").Parse( ```
// 	// {{.Name}} is the fields needed to store a DNS record of type{{.Name}}
// 	```
// )
// if err != nil { panic(err) }
// err = tmpl.Execute(b, rt)
// if err != nil { panic(err) }

// 	b.WriteString("\n")
// 	b.WriteString("// " + rt.Name + " is the fields needed to store a DNS record of type" + rt.Name + "\n")
// 	b.WriteString("type " + rt.Name + " struct {\n")
// 	for _, field := range rt.Fields {
// 		var ty string
// 		switch field.Type {
// 		case "ipv4":
// 			ty = "[4]byte"
// 		case "hostname_or_dot":
// 			ty = "string"
// 		case "ipv6":
// 			ty = "[16]byte"
// 		}
// 		b.WriteString("\t" + field.Name + " " + ty + "\n")
// 	}
// 	b.WriteString("}\n")
// 	return b.String()
// }
