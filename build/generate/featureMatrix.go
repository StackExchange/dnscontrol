package main

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"sort"

	"github.com/StackExchange/dnscontrol/providers"
	_ "github.com/StackExchange/dnscontrol/providers/_all"
)

func generateFeatureMatrix() error {
	allNames := map[string]bool{}
	for n := range providers.RegistrarTypes {
		allNames[n] = true
	}
	for n := range providers.DNSProviderTypes {
		allNames[n] = true
	}
	providerTypes := []string{}
	for n := range allNames {
		providerTypes = append(providerTypes, n)
	}
	sort.Strings(providerTypes)
	matrix := &FeatureMatrix{
		Providers: map[string]FeatureMap{},
		Features: []FeatureDef{
			{"Registrar", "The provider has registrar capabilities to set nameservers for zones"},
			{"DNS Provider", "Can manage and serve DNS zones"},
			{"ALIAS", "Provider supports some kind of ALIAS,ANAME or flattened CNAME record type"},
			{"SRV", "Driver has explicitly implemented SRV record management"},
			{"PTR", "Provider supports adding PTR records for reverse lookup zones"},
			{"CAA", "Provider can manage CAA records"},
		},
	}
	for _, p := range providerTypes {
		if p == "NONE" {
			continue
		}
		fm := FeatureMap{}
		fm.SetSimple("Registrar", func() bool { return providers.RegistrarTypes[p] != nil })
		fm.SetSimple("DNS Provider", func() bool { return providers.DNSProviderTypes[p] != nil })
		setCap := func(name string, cap providers.Capability) {
			fm.SetSimple(name, func() bool { return providers.ProviderHasCabability(p, cap) })
		}
		setCap("ALIAS", providers.CanUseAlias)
		setCap("SRV", providers.CanUseSRV)
		setCap("PTR", providers.CanUsePTR)
		setCap("CAA", providers.CanUseCAA)

		matrix.Providers[p] = fm
	}
	buf := &bytes.Buffer{}
	err := tmpl.Execute(buf, matrix)
	if err != nil {
		return err
	}
	fmt.Println(buf.String())
	return ioutil.WriteFile("docs/_includes/matrix.html", buf.Bytes(), 0644)
}

type featureStatus byte

const (
	StUndefined featureStatus = iota
	StOK
	StNotOk
	StInfo
)

func (f featureStatus) TDClass() string {
	switch f {
	case StOK:
		return "success"
	case StNotOk:
		return "danger"
	case StInfo:
		return "info"
	default:
		return ""
	}
}

func (f featureStatus) GlyphClass() string {
	switch f {
	case StOK:
		return "fa-check text-success"
	case StNotOk:
		return "fa-times text-danger"
	case StInfo:
		return "fa-info text-info"
	default:
		return ""
	}
}

type FeatureState struct {
	Status  featureStatus
	Comment string
}
type FeatureDef struct {
	Name, Desc string
}
type FeatureMap map[string]*FeatureState

func (fm FeatureMap) SetSimple(name string, f func() bool) {
	if f() {
		fm[name] = &FeatureState{Status: StOK}
	}
}

type FeatureMatrix struct {
	Features  []FeatureDef
	Providers map[string]FeatureMap
}

var tmpl = template.Must(template.New("").Funcs(template.FuncMap{
	"safe": func(s string) template.HTML { return template.HTML(s) },
}).Parse(`
	{{safe "<!-- Matrix generated by build/generate/featureMatrix.go -->"}}{{$providers := .Providers}}
<table class="table-header-rotated">
<thead>
	<tr>
	<th></th>
	{{range $key,$val := $providers}}<th class="rotate"><div><span>{{$key}}</span></div></th>
	{{end -}}
	</tr>
</thead>
<tbody>
	{{range .Features}}{{$name := .Name}}<tr>
		<th class="row-header" style="text-decoration: underline;" data-toggle="tooltip" data-container="body" data-placement="top" title="{{.Desc}}">{{$name}}</th>
		{{range $pname, $features := $providers}}{{$f := index $features $name}}{{if $f -}}
		<td class="{{$f.Status.TDClass}}"
			{{- if $f.Comment}} data-toggle="tooltip" data-container="body" data-placement="top" title="{{$f.Comment}}"{{end}}>
			<i class="fa {{if $f.Comment}}has-tooltip {{end}}
				{{- $f.Status.GlyphClass}}" aria-hidden="true"></i>
		</td>
		{{- else}}<td><i class="fa fa-minus dim"></i></td>{{end}}
		{{end -}}
	</tr>
	{{end -}}
</tbody>
</table>
`))
